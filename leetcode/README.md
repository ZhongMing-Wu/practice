#### Leetcode 总结

**回文串相关问题（参考5，214）**
- 对于偶数和奇数两种长度情况的回文串判断可以通过插入其他字符，最终只需要处理奇数长度的回文串判断。
    例：aabb -> #a#a#b#b#  aacbb -> #a#a#c#b#b#
- 对于求一个字符串的最长前缀或者最长后缀回文串，可以借用 KMP 算法的思想, 主要依据是回文串翻转后是不变的。
    例：abbacc -> abbacc#ccabba$ 根据 KMP 算法，$ 位置的 next 数组的值指向 index = 3
- 对于求一个字符串的最长回文子串，采用 **Manacher 算法**

**一种较难想到的二分思路(参考 378)**
- 对于找第 k 大(小)的问题，主要思路是堆排序，但是应该充分考虑题目条件。

**背包问题说明**
- 背包问题：指通过某些条件进行限制，对应为背包的容量是有限的，然后去寻找最优解。
- 背包问题可以分为两种情况：1. 在可重复使用的情况下，可以考虑从小到大进行 DP。 2. 在不佳而重复使用的情况下，考虑从大到小进行 DP。

**状态压缩动态规划的说明**
- 状态压缩动态规划的含义：所谓状态压缩，即我们在表示一个复杂对象的状态时(比如一个集合，一个数组)，可以通过一个整数的二进制中 1 的位置来表示。例：
数组 arr 中存在元素 1, 2, 3, 4, 5, 6，要从该数组中任意取出固定长度的子集，如果真的每一次都用一个集合来存储，会比较麻烦且不易于操作，考虑状态压缩的思想，用一个整数的二进制中1的位置表示取出的数在原数组中的下标，比如 3 二进制位 11 表示取出原数组的 1 和 2，故整数3就可以表示一个集合。
- 使用状态压缩后，再使用动态规划会简化动态规划的操作，可以参考1681，1659。

**差分数组的说明**
- 可参考题 1674
- 差分数组就是一个普通的数组，例 num[10]，不过该数组中的数据表示某一个数组 arr 中对应下标对应的值与前一个下标对应的值的差值。比如 num[4] = 3; 表示 arr[4] - arr[3] = 3。 
- 在某些情景下，在求 arr 每一个值的时候，不需要直接求取，可以先求到 arr 对应的差分数组，然后根据差分数组求数组 arr 的每一个值。例： arr[i] = arr[i - 1] + num[i]; arr[0] = num[0];
- 如果每次操作都需要更新整个数组，并且更新时，数组的一部分是相同的更新，可以考虑差分数组替代整体更新。差分数组的作用通俗一点的说明就是用于表征结果数组中元素的关系。

**树状数组的说明**
- 可参考题 315
- [树状数组的详细说明](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/)
- 树状数组主要利用二进制数的一些性质。
- 主要用于求前缀和

**单调队列的说明**
- 单调队列，主要用来维护给定大小的区间的最值。这样的好处是每一次获取最值时的时间复杂度都是 O(1)。
- 可以参考 [单调队列](https://www.jianshu.com/p/e59d51e1eef5)

**常用的优先级比较**
- 算术运算符 > 移位运算符 > 关系运算符 > 位操作运算符(& | ^) > 复制运算符

**解决问题的两大总体思路**
- 使用某种技巧或者算法解决问题。
- 遍历解决问题。(使用遍历的方法时，常考虑状态压缩)。
