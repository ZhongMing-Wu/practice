#### Leetcode 总结

**回文串相关问题（参考5，214）**
- 对于偶数和奇数两种长度情况的回文串判断可以通过插入其他字符，最终只需要处理奇数长度的回文串判断。
    例：aabb -> #a#a#b#b#  aacbb -> #a#a#c#b#b#
- 对于求一个字符串的最长前缀或者最长后缀回文串，可以借用 KMP 算法的思想, 主要依据是回文串翻转后是不变的。
    例：abbacc -> abbacc#ccabba$ 根据 KMP 算法，$ 位置的 next 数组的值指向 index = 3
- 对于求一个字符串的最长回文子串，采用 **Manacher 算法**

**一种较难想到的二分思路(参考 378)**
- 对于找第 k 大(小)的问题，主要思路是堆排序，但是应该充分考虑题目条件。

**背包问题说明**
- 背包问题：指通过某些条件进行限制，对应为背包的容量是有限的，然后去寻找最优解。
- 背包问题可以分为两种情况：1. 在可重复使用的情况下，可以考虑从小到大进行 DP。 2. 在不佳而重复使用的情况下，考虑从大到小进行 DP。

**状态压缩动态规划的说明**
- 状态压缩动态规划的含义：所谓状态压缩，即我们在表示一个复杂对象的状态时(比如一个集合，一个数组)，可以通过一个整数的二进制中 1 的位置来表示。例：
数组 arr 中存在元素 1, 2, 3, 4, 5, 6，要从该数组中任意取出固定长度的子集，如果真的每一次都用一个集合来存储，会比较麻烦且不易于操作，考虑状态压缩的思想，用一个整数的二进制中1的位置表示取出的数在原数组中的下标，比如 3 二进制位 11 表示取出原数组的 1 和 2，故整数3就可以表示一个集合。
- 使用状态压缩后，再使用动态规划会简化动态规划的操作，可以参考1681，1659。

**差分数组的说明**
- 可参考题 1674
- 差分数组就是一个普通的数组，例 num[10]，不过该数组中的数据表示某一个数组 arr 中对应下标对应的值与前一个下标对应的值的差值。比如 num[4] = 3; 表示 arr[4] - arr[3] = 3。 
- 在某些情景下，在求 arr 每一个值的时候，不需要直接求取，可以先求到 arr 对应的差分数组，然后根据差分数组求数组 arr 的每一个值。例： arr[i] = arr[i - 1] + num[i]; arr[0] = num[0];
- 如果每次操作都需要更新整个数组，并且更新时，数组的一部分是相同的更新，可以考虑差分数组替代整体更新。差分数组的作用通俗一点的说明就是用于表征结果数组中元素的关系。

**树状数组的说明**
- 可参考题 315
- [树状数组的详细说明](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/)
- 树状数组主要利用二进制数的一些性质。
- 主要用于求前缀和

**单调队列的说明**
- 单调队列，主要用来维护给定大小的区间的最值。这样的好处是每一次获取最值时的时间复杂度都是 O(1)。
- 可以参考 [单调队列](https://www.jianshu.com/p/e59d51e1eef5)

**常用的优先级比较**
- 算术运算符 > 移位运算符 > 关系运算符 > 位操作运算符(& | ^) > 复制运算符

**解决问题的两大总体思路**
- 使用某种技巧或者算法解决问题。
- 遍历解决问题。(使用遍历的方法时，常考虑状态压缩)。


**求最小生成树**
- prim 算法 ------ 从点出发。
- 克鲁斯卡尔算法 ------ 从边出发，会使用到并查集。

**对于处理二维矩阵的一种思想**
- 在处理二维矩阵时，如果需要考虑元素与元素之间的关系，一种思路是将其看作是一个图，然后利用图的一些算法来求解。比如题 1631，可以利用图中常用的迪杰斯特拉算法或者克鲁斯卡尔算法求解。

**对于 DP + 累加的问题**
- 详见 1638。在该题中，dp[m][n] 不能代表最终结果，而是代表部分结果，最终结果应该由各个dp[i][j] 累加得到。

**floyed 算法**
- 详见 1617

**关于求随机数的一个思想**
- 例：函数 rand10 可以返回一个 1 - 10 的随机数(获取任意数概率相等)，实现函数 rand7 返回 1- 7 的随机数。
对于通过一个大范围的求随机数函数实现一个小范围的求随机数的函数，只需要 rand10 获取一个数 a，如果 a 在 1-7 范围内，则直接返回，这种实现方式对于 1-7 的任意数的概率是相同的。对于通过一个小范围的求随机数函数实现一个大范围的求随机数的函数，需要先将小范围的求随机数函数扩展到比大范围的待求函数更大的范围。比如 rand7 实现rand10，需要先通过 rand7 扩大随机数范围，(rand7 - 1) * 7 + rand7 随机数范围扩大至 1- 50，然后通过该等式得到一个随机数 a，如果 a 在 1-10，则直接返回。
- 对于 (rand7 - 1) * 7 + rand7 是如何获得的，思路是需要考虑等概率填满整个区间即可。ran7获得 1-7 的数，扩大 b 倍后，每个数之间间隔为 b,需要将间隔填满，但是目前只有一个 rand7 可以使用，所以考虑让扩大后的相邻数之间的间隔为 7，所以扩大 7 倍。由于需求是 1-某个数，所以需要 rand7 - 1。

**自定义链表的实现**
- Java 自带的 linkedlist 类的 remove 操作的时间复杂度是 O(n)，如果需要一个时间复杂度为 O(1) 的链表，可以自定义实现。参考题 460
```java
class Node {
    public int key;
    public int val;
    public int freq;
    public Node next;
    public Node pre;
}
class MyLinkedList {
    public Node head, tail;
    public int size;
    public MyLinkedList() {
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;

        size = 0;
    }

    public void removeNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
        node.pre = null;
        node.next = null;
        --size;
    }

    public void addLast(Node node) {
        Node temp = tail.pre;
        temp.next = node;
        node.pre = temp;
        node.next = tail;
        tail.pre = node;
        ++size;
    }
}
```

**关于字典序问题**
- 字典序排序本质上是多叉树的先序遍历。也可以看作是深度优先遍历来处理。

**求解局部最小值问题**
- 在遍历时，对于每次都要去求解局部最小值，可以考虑使用一个栈或队列来动态记录，从而实现找最小值的时间复杂度为 O(1)。可参考题 402

**DP 和 二分查找的两个使用依据**
- 将数组分割为 m 段，求…… 是动态规划题目常见的问法。
- 使……最大值尽可能小是二分搜索题目常见的问法。参考 题887 和 题410

**关于 1 对 多问题**
- 如果 从 1 开始处理，不好处理，可以考虑 多 对 1 进行处理(即分别讨论)。参考题 417

**二叉树中序 mirrors 遍历**
- 在遍历到一个节点的时候，找到该节点左子节点的最右节点，该最右节点的右节点一定为 null，让该最右节点的右节点指向当前节点，这样中序遍历时的空间复杂度为 O(1)

**求前 K 个数的一种思路**
- 对于求前 K 个值的问题，可以考虑堆排序或者快速排序(使用快排需要题中对于前 K 个数的顺序没有要求)。

**数组中找重复的数的一种思路**
- 对于 题287 的这种情况，可以采用快慢指针的思路去解决。