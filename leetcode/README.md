#### Leetcode 总结

##### 回文串相关问题（参考5，214）
- 对于偶数和奇数两种长度情况的回文串判断可以通过插入其他字符，最终只需要处理奇数长度的回文串判断。
    例：aabb -> #a#a#b#b#  aacbb -> #a#a#c#b#b#
- 对于求一个字符串的最长前缀或者最长后缀回文串，可以借用 KMP 算法的思想, 主要依据是回文串翻转后是不变的。
    例：abbacc -> abbacc#ccabba$ 根据 KMP 算法，$ 位置的 next 数组的值指向 index = 3
- 对于求一个字符串的最长回文子串，采用 **Manacher 算法**

##### 一种较难想到的二分思路(参考 378)
- 对于找第 k 大(小)的问题，主要思路是堆排序，但是该充分应考虑目条题件。

##### 背包问题说明
- 背包问题：指通过某些条件进行限制，对应为背包的容量是有限的，然后去寻找最优解。
- 背包问题可以分为两种情况：1. 在可重复使用的情况下，可以考虑从小到大进行 DP。 2. 在不可重复使用的情况下，考虑从大到小进行 DP。

##### 状态压缩动态规划的说明
- 状态压缩动态规划的含义：所谓状态压缩，即我们在表示一个复杂对象的状态时(比如一个集合，一个数组)，可以通过一个整数的二进制中 1 的位置来表示。例：
数组 arr 中存在元素 1, 2, 3, 4, 5, 6，要从该数组中任意取出固定长度的子集，如果真的每一次都用一个集合来存储，会比较麻烦且不易于操作，考虑状态压缩的思想，用一个整数的二进制中1的位置表示取出的数在原数组中的下标，比如 3 二进制位 11 表示取出原数组的 1 和 2，故整数3就可以表示一个集合。
- 使用状态压缩后，再使用动态规划会简化动态规划的操作，可以参考1681，1659。

##### 差分数组的说明
- 可参考题 1674
- 差分数组就是一个普通的数组，例 num[10]，不过该数组中的数据表示某一个数组 arr 中对应下标对应的值与前一个下标对应的值的差值。比如 num[4] = 3; 表示 arr[4] - arr[3] = 3。 
- 在某些情景下，在求 arr 每一个值的时候，不需要直接求取，可以先求到 arr 对应的差分数组，然后根据差分数组求数组 arr 的每一个值。例： arr[i] = arr[i - 1] + num[i]; arr[0] = num[0];
- 如果每次操作都需要更新整个数组，并且更新时，数组的一部分是相同的更新，可以考虑差分数组替代整体更新。差分数组的作用通俗一点的说明就是用于表征结果数组中元素的关系。

##### 树状数组的说明
- 可参考题 315
- [树状数组的详细说明](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/)
- 树状数组主要利用二进制数的一些性质。
- 主要用于求前缀和

##### 单调队列的说明
- 单调队列，主要用来维护给定大小的区间的最值，单调队列里面不直接存储值，而是存储下标，这样方便判断当前最大值是否在规定范围以内。这样的好处是每一次获取最值时的时间复杂度都是 O(1)。
- 可以参考 [单调队列](https://www.jianshu.com/p/e59d51e1eef5)

##### 常用的优先级比较
- 算术运算符 > 移位运算符 > 关系运算符 > 位操作运算符(& | ^) > 复制运算符

##### 解决问题的两大总体思路
- 使用某种技巧或者算法解决问题。
- 遍历解决问题。(使用遍历的方法时，常考虑状态压缩)。


##### 求最小生成树
- prim 算法 ------ 从点出发。
- 克鲁斯卡尔算法 ------ 从边出发，会使用到并查集。

##### 对于处理二维矩阵的一种思想
- 在处理二维矩阵时，如果需要考虑元素与元素之间的关系，一种思路是将其看作是一个图，然后利用图的一些算法来求解。比如题 1631，可以利用图中常用的迪杰斯特拉算法或者克鲁斯卡尔算法求解。

##### 对于 DP + 累加的问题
- 详见 1638。在该题中，dp[m][n] 不能代表最终结果，而是代表部分结果，最终结果应该由各个dp[i][j] 累加得到。

##### floyed 算法
- 详见 1617

##### 关于求随机数的一个思想
- 例：函数 rand10 可以返回一个 1 - 10 的随机数(获取任意数概率相等)，实现函数 rand7 返回 1- 7 的随机数。
对于通过一个大范围的求随机数函数实现一个小范围的求随机数的函数，只需要 rand10 获取一个数 a，如果 a 在 1-7 范围内，则直接返回，这种实现方式对于 1-7 的任意数的概率是相同的。对于通过一个小范围的求随机数函数实现一个大范围的求随机数的函数，需要先将小范围的求随机数函数扩展到比大范围的待求函数更大的范围。比如 rand7 实现rand10，需要先通过 rand7 扩大随机数范围，(rand7 - 1) * 7 + rand7 随机数范围扩大至 1- 50，然后通过该等式得到一个随机数 a，如果 a 在 1-10，则直接返回。
- 对于 (rand7 - 1) * 7 + rand7 是如何获得的，思路是需要考虑等概率填满整个区间即可。ran7获得 1-7 的数，扩大 b 倍后，每个数之间间隔为 b,需要将间隔填满，但是目前只有一个 rand7 可以使用，所以考虑让扩大后的相邻数之间的间隔为 7，所以扩大 7 倍。由于需求是 1-某个数，所以需要 rand7 - 1。

##### 自定义链表的实现
- Java 自带的 linkedlist 类的 remove 操作的时间复杂度是 O(n)，如果需要一个时间复杂度为 O(1) 的链表，可以自定义实现。参考题 460
```java
class Node {
    public int key;
    public int val;
    public int freq;
    public Node next;
    public Node pre;
}
class MyLinkedList {
    public Node head, tail;
    public int size;
    public MyLinkedList() {
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;

        size = 0;
    }

    public void removeNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
        node.pre = null;
        node.next = null;
        --size;
    }

    public void addLast(Node node) {
        Node temp = tail.pre;
        temp.next = node;
        node.pre = temp;
        node.next = tail;
        tail.pre = node;
        ++size;
    }
}
```

##### 关于字典序问题
- 字典序排序本质上是多叉树的先序遍历。也可以看作是深度优先遍历来处理。

##### 求解局部最小值问题
- 在遍历时，对于每次都要去求解局部最小值，可以考虑使用一个栈或队列来动态记录，从而实现找最小值的时间复杂度为 O(1)。可参考题 402

##### DP 和 二分查找的两个使用依据
- 将数组分割为 m 段，求…… 是动态规划题目常见的问法。
- 使……最大值尽可能小是二分搜索题目常见的问法，一种思路是假设一个答案，然后反向去验证。参考 题887 和 题410

##### 关于 1 对 多问题
- 如果 从 1 开始处理，不好处理，可以考虑 多 对 1 进行处理(即分别讨论)。参考题 417

##### 二叉树中序 mirrors 遍历
- 在遍历到一个节点的时候，找到该节点左子节点的最右节点，该最右节点的右节点一定为 null，让该最右节点的右节点指向当前节点，这样中序遍历时的空间复杂度为 O(1)

##### 求前 K 个数的一种思路
- 对于求前 K 个值的问题，可以考虑堆排序或者快速排序(使用快排需要题中对于前 K 个数的顺序没有要求)。

##### 数组中找重复的数的一种思路
- 对于 题287 的这种情况，可以采用快慢指针的思路去解决。

##### 对于连续子串的相关问题的一种处理思路
- 针对求连续子串(子数组)问题，一种思路是考虑前缀和，因为任何连续子串都可以由两个前缀和相减得到。
- 一种减少时间复杂度的有效方式是通过一个单调栈或者单调队列记录数据信息，至于按照哪种方式进行单调处理，需要根据题意去探究（这里是解决这种问题的痛点）。

##### 关于证明一个封闭图形是凸多边形的问题
- 判断一个封闭图形是不是凸多边形，就是判断所有边的向量积是否同号(可以通过两两一次判断)。
- 向量积为 0，表示两条边平行，这时需要跳过，不能去改变记录的上一个向量积。
- 向量积的计算：(x1, y1) 和 (x2, y2)为两个向量 向量积 = x1 * y2 - y1 * x2;

##### 关于树形DP问题
- 在处理树形DP时，一般的思路是先递归处理子节点，然后根据子节点的不同情况，处理父节点，得到父节点的最优解，可参考[打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)。
- 树形DP的第二种情况是结合背包问题，思路可以概括为从左到右依次递归处理，局部到整体的处理方式，可参考(https://oi-wiki.org/dp/tree/)中的树上背包
- 树形DP的第三种情况是换根问题，通过条件中没有指定根节点，可以看作是一个图，这时可以先指定一个根节点进行一次递归处理，获取一些条件，然后再换一个节点作为根进行处理。当换一个节点作为根进行处理时，可以考虑前面的根处理好的结果是否可利用，可参考(https://oi-wiki.org/dp/tree/)中的换根DP
- ！！！所有的由 N 个节点和 N - 1 条边组成的完全连通图都可以当作一个树来处理。！！！

##### 关于 1-0 背包问题
- 每个物体只有 2 种可能的状态（使用与不使用），正如二进制中的 0 和 1 ，这类问题便被称为「0-1 背包问题」。
- 一般的思路是从左到右一次遍历，遍历到第 i 个节点时，是一定会考虑第 i 个节点的，因为如果不考虑的话，等价于处理前 i - 1 个节点的情况。
- 假设容量为 W，则数组中存储是1-W容量在前i个元素中的最优值。(dp[1], dp[2] ... dp[W])
- 对于 1-0 背包问题，用一个一维数组进行 DP 就可以了，因为求dp[i] 时，只使用了 dp[i - 1]，不需要存储 i - 1 之前的情况，设背包容量为 W，则只需要一个一维数组存储容量从1 - W 在前 i - 1 个元素中的最优值，然后用来求前 i 个元素的最优值。但是要从大到小进行遍历，不然会出现覆盖问题，**这里之所以不能覆盖**是因为所有的物体只能使用一次，如果从小到大遍历，有可能当前情况的最优值是使用当前物体的情况(比如 dp[i] 当前的最优值是使用当前物体的情况)，那么后面在计算 dp[j] 时，如果使用了前面的 dp[i]，这时因为 dp[i] 可能是使用了当前物体的最优值，而 dp[j] 计算时有可能也会使用当前物体，也就是一个物体被使用了多次，这是不对的。(完全背包不存在这种问题，因为物体可以被使用多次)
- 对于0 - 1背包问题，从大到小进行 DP。

##### 关于完全背包问题
- 完全背包和 0-1 背包是一样的，只是完全背包物体的使用次数是无限次，所以我们可以从小到大考虑，不用担心覆盖会出现问题。
- 对于求 dp[i] 的最优解时，为什么不用考虑当前物体的使用次数，只需要考虑使用一次的情况，以(https://oi-wiki.org/dp/knapsack/)里面完全背包的题为例，求解 dp[l + w[i]] = Math.max(dp[l + w[i]], dp[l] + v[i]) 为什么这里只使用一次 v[i] 即可，不用考虑 v[i] * 使用次数，因为 dp[l] 的最优解可能已经使用过 v[i] 了。对于考虑v[i] * 使用次数的这种想法，是基于 dp[l]当前的最优解都没有考虑 v[i] 的情况，但是就算考虑v[i] * 使用次数，我们所求的就是对于 l = l1 + 1 * w[i] = l2 + 2 * w[i]... = lx + x * w[i]，这些情况下 dp[l] 的最优值。其实 l1 + 1 * w[i],l2 + 2 * w[i]...lx + x * w[i] 都可以转换成 l1 + 1 * w[i] 的情况，所以我们求解 dp[l] 的最优值，其实只需要利用 dp[l1] 的最优解即可，而dp[l1] 的最优解已经有了。

##### 0 - 1背包和完全背包小结
- 0-1 背包的DP过程一般从大到小计算，而完全背包DP 过程从小到大计算。

##### 关于多重背包问题
- 所谓多重背包，即每个物品的使用次数是有限次的。
- 多重背包的解决思路和 0-1 背包一样，即可以将某种物品选 k 次转换成 k 中相同的物品选一次，比如现在由 A,B 两种物品, A 可以选 3 次，B 可以选 2 次，可以转换成 由五个物品，分别是 A,A,A,B,B 这样就可以通过 0-1 背包的思路去解决。但是！！！这样其实会有很多重复的操作，举例来说，我们考虑了「同时选 A1 和 A2」与「同时选 A2 和 A3」这两个完全等效的情况。这样的重复性工作我们进行了许多次。所以需要优化。
- 通过二进制分组进行优化，还是 0-1 背包的思路，不过对于每一种物品不在分成 A,A,A,B,B 这种情况，而是分成 A,(A,A),B,B 这样的形势。
- 以下为几个例子：
   - 6 = 1 + 2 + 3
   - 8 = 1 + 2 + 4 + 1
   - 18 = 1 + 2 + 4 + 8 + 3
   - 最后剩下的作为单独一组。
- 通过这种方式，可以减少新的数组的长度，并且能够包含所有的情况。以 8 为例：1， 2， 3 = 1 + 2， 4， 5 = 4 + 1， 6 = 4 + 2， 7 = 1 + 2 + 4， 8 = 1 + 2 + 4 + 1

##### 关于二维(甚至多为)背包问题
- 其实就是一维背包的升级版，这时一维数组就不够用了，需要用对应维度的数组，比如二维背包应该用一个二维数组存储。至于二维背包中的 0-1 背包，完全背包和多重背包和一维的思路完全一样，只是需要多一重循环。

##### 分组背包
- 所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。
- 思路就是每一个组看作是一个整体，那么可以借鉴 0-1 背包的思路，不过这里多一重循环，用于遍历同一个组中的所有物体。
- 这里的循环顺序比较重要，应该是先循环背包容量，然后循环遍历组内的所有物体，如果顺序反了，会导致最优值可能是在选择同一组的多个物品获取的。举个例子：w1 和 w1 是同一组的两个不同物体的体积，使用 w1 计算 dp[x + w1] 的最优值是选取 w1 的情况，那么在计算 dp[x + w1 + w2] 的最优值时，可能 dp[x + w1 + w2] 的最优值为 dp[x + w1] + v2 这种情况，那么同一组的物体就被选用了多个。所有循环顺序是先容量，再物体，如下：
```
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])
        dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

##### 关于回溯的一些说明
- 对于无线长度的回溯，考虑使用递归的方式处理，对于有线长度的回溯(比如该题)，可以考虑多重循环处理。(参考题 93)

##### 关于通过后序遍历的一个数组建立二叉搜索树
- 不需要同时记录后序遍历和中序遍历两个数组，因为二叉搜索树是有序的，在后序遍历的数组中，凡是比当前的 root 节点(即当前状态数组的最后一个元素)小的都是左孩子节点，比当前 root 节点大的都是右孩子节点。(参考 剑指offer 33)

##### 一种思路的小结
- 对于高度差问题，一般都考虑木桶原理，从最外围到里面进行处理。
- 对于二维矩阵的处理不要拘泥于按顺序处理，比如这种有边界的问题，从任意一个点入手都是有可能的，通过题 407 体会思想。

##### 一种很难受的题
- 详见 179，1754，体会思想。
- 关于比较两个字符串连接起来谁比较大的问题。比如 abc 和 abcd，求怎样连接字典序更大的问题，可以先连接，然后再比较。 即比较 abc-abcd 和 abcd-abc

##### 关于 0-1 字典树的使用
- `对于位运算相关的题(特别是异或)，可以考虑 0-1字典树`，从高位(30)到低位(0) 0 和 1 组成一个字典树，然后再去求解。
- 对于字典树中的节点，有时需要保存一些关键信息，方便处理。比如题 1707 每个节点保存通过该节点的最小值，那么就可以直接判断通过该节点的数是否有小于目标数的数。对于 5696 那道题，每个节点需要保存的是通过这个节点的数的个数。对于节点需要保存哪一种信息，需要根据题意确定。
- 对于 0-1 字典树节点的构造推荐下面这种方式：
```
class BinaryTreeNode {
    // 根据题意需要提供的一些信息
    ...
    // 孩子节点，因为只有 0 1，所以用一个长度为 2 的数组保存，非常方便使用。
    BinaryTreeNode[] children = new BinaryTreeNode[2];
}
```

##### 在某些情况下，DP 不一定效率最好
- 通常情况下，DP的效率高于递归，但是在数值很大的情况下(比如题 1553)，DP 不一定能够满足时间条件,递归本身可能效率也不高，但是`递归+剪枝`能够有效提高效率。

##### 滑动窗口的两种形式
1. 常见的就是通过两个指针就行，比如一个 left 一个 right 指针。
2. 还有一种是整体移动的方式，参考题 718。

##### 关于深搜和广搜的一个注意点
- 在进行深搜和广搜时，通常会使用一个 visited 数组，**需要考虑清楚设置 visited 的时机**，不然容易出问题。参考题 529。

##### 区间DP问题
- 问题的特征一般是能将问题分解为能两两合并的形式，即将两个或者多个部分进行整合，反过来也是可以的。
- 这种问题一般先从小到大枚举 len，，然后枚举起点，然后在区间 [start, start + len - 1] 中枚举中间节点，将区间分为两个部分，寻找最优值，时间复杂度一般为 O(n3)
- 区间 DP 问题可能会涉及环的问题，一种比较好的解决办法是将这个环当作一个链，然后延长一倍，其中 i 和 n + i 相同，用上面的思路求解后，取[0, n - 1], [1, n], [2, n + 1], ..., [i, n + i - 1] 的最优值 

##### 数位DP问题
- 数位DP问题往往都是这样的题型，给定一个闭区间 [l, r]，求这个区间中满足某种条件的数的总数
- 第一步：**转换成前缀问题**，分别求出 [0, l] 和[0, r] 满足条件的数的总数，然后相减即可。第二步：关于数的处理，一位一位的进行处理(一般从高位到低位进行处理)，比如 12345，分别处理 1， 2， 3， 4， 5，从高位处理到低位。
- 以下面这道题的代码为例：
```cpp
// 找出给定范围中，不包含62 和 4 的数的个数，即 162 和 14这种是不符合条件的
// 数位DP的思想详见代码注解
#include<bits/stdc++.h>
using namespace std;
int dp[20][2],a[20];
int n,m;
int dfs(int pos,int pre,int sta,bool limit)
{
    // 表明已经遍历到最后一位之后，直接返回 +1
    if(pos==-1)return 1;
    // 这里对于可以任意取值的情况，因为会重复查找，所以可以存储起来，访问时直接返回，即进行剪枝
    if(!limit&&dp[pos][sta]!=-1)return dp[pos][sta];
    // 判断是否可以 0-9 任意取值
    int up=limit?a[pos]:9;
    int temp=0;
    for(int i=0; i<=up; i++)
    {
        // 出现 4 表明不符合条件，跳过
        if(i==4)continue;
        // 出现 62 表明不符合条件，跳过
        if(pre==6&&i==2)continue;
        // 当前状态符合条件，则深搜下一位
        temp+=dfs(pos-1,i,i==6,limit&&i==a[pos]);
    }
    // 对于 limit == false 的情况存储起来，方便下次直接使用
    // 对于 sta 为什么需要的原因是，当前位符合条件的个数是和上一位的值有关系的，比如这道题中，上一位为 6或者不为 6，当前位符合条件的数的个数是不同的，如果只使用一个一维数组保存，是不正确的。至于 dp 的第二维的长度，应该根据题意确定，比如该题只需要 2，不需要 0-9 == 10 的长度，因为这里只需要考虑前一位是否为 6 两种情况，0-5 和 7-9 是相同的。
    if(!limit)dp[pos][sta]=temp;
    return temp;
}
int solve(int x)
{
    int pos=0;
    while(x)
    {
        a[pos++]=x%10;
        x/=10;
    }
    // limit == true 表明前面都是处于上限，例：34378 当前遍历到 7 这个位置，前面的数为 343，所以后面的数不能够 0-9 任意取值
    // limit == false 表明前面个的有某些位没有处于上限，例：34378 当前遍历到 7 这个位置，前面的数为 341，所以后面的数能够 0-9 任意取值
    // limit 为 true 的情况整个过程只会处理一次，所以不需要存储，limit 为 false 的情况整个过程会处理多次，所以考虑存储起来，这样可以用于剪枝操作
    return dfs(pos-1,-1,0,true);
}
int main()
{
    int l,r;

    while(~scanf("%d%d",&l,&r)&&l+r)
    {
        memset(dp,-1,sizeof(dp));
        // 将范围求解转换成前缀求解的方式
        printf("%d\n",solve(r)-solve(l-1));
    }
    return 0;
}
```

##### 状态的一致性问题
- 当人为的设置某种状态的时候，需要保证这种状态的一致性，参考题 1463(由于做题的时候没有考虑一致性，应该赋 -1, 赋成了 0，导致问题，详见代码).